{\rtf1\ansi\ansicpg1252\cocoartf1344\cocoasubrtf720
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww13240\viewh15580\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs26 \cf0 A. fra boken\
16.5\
16.6\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\fs24 \cf0 B. \
Bevis at for enhver ikke-tom liste [x1,x2,\'85,xn], holder likheten:  \
	foldr f v [x1,x2,\'85,xn]  =  f x1 (f x2 (\'85 (f xn v) \'85)). \
\
\
C. \
C1. Skriv en rekursiv funksjon bsum :: Fractional t => Int -> t, som regner ut summen av alle br\'f8kene p\'e5 formen 1/(n*(n+1)) for alle n fom. 1 tom. det aktuelle argumentet (som antas >= 1), f.eks., \
\
	bsum 1 = 1/(1*2)\
	bsum 3 = 1/(1*2) + 1/(2*3) + 1/(3*4) \
\
C2. Bevis korrekthet av din implementasjon.\
\
C3. Bruk n\'e5 induksjon for \'e5 bevise at for alle naturlige tall n: \
\
	1/(1*2) + 1/(2*3) + 1/(3*4) +\'85 + 1/(n*(n+1))  =  n/(n+1)\
\
C4. Implementer bsum p\'e5 en enkel, ikke rekursiv m\'e5te.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\fs26 \cf0 \
D. Definer en funksjon\
	sub :: [t] -> [t] -> [t]\
som fjerner fra f\'f8rste liste alle elementene i den andre, f.eks. \
	sub [1,2,1,3,2,1,4,5,6,1] [1,6] = [2,3,2,4,5]\
	sub [1,2,1,3,2,1,4,5,6,1] [2,3,4] = [1,1,1,5,6,1]\
Bevis at resulterende liste ikke inneholder noen elementer fra den andre argumentlisten.\
\
E. Funksjonen \
	map :: (a -> b) -> [a] -> [b]\
er definert ved:\
	map f [] = []\
	map f (x:xs) = (f x) : map f xs\
Bevis, ved induksjon p\'e5 listens lengde at:\
	1. map id = id \
dvs. at for enhver liste xs, holder likheten: map id xs = xs, og\
	2. map (f . g) = (map f) . (map g)\
dvs. at for enhver liste xs, har vi: map (f . g) xs = (map f) . (map g) xs.\
\
\
F. Definer en parametrisert dataype av bin\'e6re tr\'e6r:  [16.8]\
	data Tree a =  Leaf a | Node (Tree a) a (Tree a)\
og en funksjon \
	fmap :: (a -> b) -> Tree a -> Tree b\
ved\
	fmap f (Leaf x) = Leaf (f x)\
	fmap (Node ve x ho) = Node (fmap f ve) (f x) (fmap f ho)\
Bevis, ved induksjon p\'e5 tr\'e6rne at\
	1. fmap id = id\
	2. fmap (f . g) = (fmap g) . (fmap h)\
\
NB. fmap p\'e5 tr\'e6rne tilsvarer map for lister - den traverserer hele tre-argumentet og anvender funksjonen f (sitt f\'f8rste argument) p\'e5 verdien i hver node i treet. \
Trestrukturen forblir uforandret, men verdiene i alle nodene (samt, muligens, typen av hele treet) endres ved anvendelse av f.\
\
}